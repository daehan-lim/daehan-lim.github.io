<!--suppress CssUnusedSymbol, JSUnusedLocalSymbols -->
<style>
/* Navigation Menu Styles */
#nav-menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  background-color: #3464e1; /* Navbar color */
  color: white;
  padding: 15px 0; /* Navbar height */
  z-index: 1000;
  display: flex;
  justify-content: space-between; /* Space between items */
  align-items: center; /* Vertically align items */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

code .nx {
  color: #24292e !important;
}


.image-row {
  display: flex;
  overflow-x: auto;
  border: 2px solid #ccc;
  padding: 6px;
  border-radius: 8px;
  gap: 5px;
  align-items: flex-start;
}

.image-item {
  width: 240px !important;
  height: auto !important;
  display: block !important;
  flex-shrink: 0 !important;
}

.linked-image {
  display: block !important;
  flex-shrink: 0 !important;
}

.markdown-body {
    font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;
    font-weight: 400 !important;
    word-break: keep-all !important;
    letter-spacing: -0.3px !important;
    line-height: 1.8 !important;
    font-size: 17px !important;
}

#nav-menu a {
  color: white;
  text-decoration: none;
  margin: 0 15px;
  font-weight: bold;
  font-size: 14px;
  transition: color 0.3s ease;
}

#nav-menu > div:first-child a { 
    margin: 0 10px;
}

#nav-menu a:hover {
  color: #f1c40f;
}

/* Adjust content padding for the fixed navbar */
body {
  padding-top: 75px; /* Adjusted for taller navbar */
}

/* Hamburger Menu (Toggle Button) */
#nav-menu-toggle {
  display: none;
  cursor: pointer;
  font-size: 18px;
  margin-right: 20px; /* Move to the right */
  z-index: 1100; /* Ensure toggle is above menu items */
}

/* Navigation Links */
#nav-links {
  display: flex;
  flex-wrap: wrap;
  padding-right: 20px;
}

@media (max-width: 768px) {
  #nav-links {
    display: none; /* Hide links initially on mobile */
    flex-direction: column;
    align-items: center;
    background-color: #3464e1; /* Match navbar background */
    width: 100%;
    position: absolute;
    top: 60px; /* Space below navbar */
    left: 0;
    padding: 15px 0; /* Add spacing around links */
    z-index: 1000; /* Ensure it doesn't overlap the toggle button */
  }

  #nav-links.active {
    display: flex; /* Show links when active */
  }

  #nav-links a {
    margin: 15px 0; /* Added vertical spacing */
  }

  #nav-menu-toggle {
    display: block; /* Show hamburger menu */
  }
}
</style>

<div id="nav-menu">
  <div style="margin-left: 20px;">
    <a href="/" class="active"></a> 
  </div>

<span id="nav-menu-toggle">☰</span>
  <div id="nav-links">
    <!-- Navigation Links will be dynamically populated -->
  </div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const navLinksContainer = document.getElementById("nav-links");
    const toggle = document.getElementById("nav-menu-toggle");
    const headings = document.querySelectorAll("h2");

    // Remove auto-generated H1 heading completely to avoid spacing issues
    const autoGeneratedH1 = document.querySelector("h1:first-of-type");
    if (autoGeneratedH1) {
      autoGeneratedH1.remove();
    }

    // Create navigation links dynamically, excluding subheadings (###)
    headings.forEach((heading, index) => {
      if (heading.tagName === "H3") return; // Skip ### subheadings

      // Create a clean title without emojis for the nav bar
      const cleanText = heading.textContent.replace(/[\u{1F300}-\u{1FAF6}]/gu, '').trim();

      // Create an ID for each heading if not already present
      if (!heading.id) {
        heading.id = "section-" + index;
      }

      // Create navigation link
      const navLink = document.createElement("a");
      navLink.href = "#" + heading.id;
      navLink.textContent = cleanText;
      navLinksContainer.appendChild(navLink);
    });

    // Add click event for hamburger toggle
    toggle.addEventListener("click", () => {
      navLinksContainer.classList.toggle("active");
    });

    // Adjust scroll behavior to account for fixed navbar height
    const adjustScroll = (e, href) => {
      e.preventDefault();
      const target = document.querySelector(href);
      if (target) {
        window.scrollTo({
          top: target.offsetTop - 75, // Offset for navbar height
          behavior: 'smooth'
        });
      }
    };

    // Handle nav bar links
    document.querySelectorAll('#nav-links a').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        adjustScroll(e, this.getAttribute('href'));
        navLinksContainer.classList.remove('active'); // Collapse the dropdown
      });
    });

    // Handle all Markdown links with hash anchors
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
      anchor.addEventListener('click', function (e) {
        adjustScroll(e, this.getAttribute('href'));
      });
    });
  });
</script>

<div style="position: relative; margin-bottom: 40px;">

<img src="https://capsule-render.vercel.app/api?type=waving&color=gradient&height=300&section=header&fontSize=45&animation=fadeIn&fontAlignY=38&desc=&descAlignY=51&descAlign=62" alt="Header" style="display: block; width: 100%; height: auto; margin: 0; padding: 0; border-radius: 8px;" />

<img src="../../images/cooki/app_icon.png" alt="Project Icon" style="position: absolute; left: 40px; bottom: -10px; width: 80px; height: 80px; border-radius: 20px; object-fit: cover;" />

</div>

# Cooki - AI 레시피 커뮤니티 앱

## 📝 개요
**📌 앱 소개:** 생성형 AI를 활용한 개인 맞춤형 레시피 생성 및 공유 플랫폼  
**🕒 기간:** 2025.06.01 ~ 2025.07.04 (5주)  
**📱 플랫폼:** Flutter 크로스 플랫폼 앱 (iOS, Android)  
**👥 개발 인원:** 3명  
**💼 역할:** AI 레시피 생성, 레시피 수정, 리뷰 관련 기능, 다국어 지원 개발, 등  
**🛠️ 사용 기술:** `Flutter` `Dart` `Firebase` `Riverpod` `Clean Architecture` `Gemini API` `Firestore` `Cloud Functions` `Google Cloud Translation API`  
**🔗 GitHub:** [flutter-fantastic-four/cooki-app](https://github.com/flutter-fantastic-four/cooki-app)  
**🔗 App Store:** [apps.apple.com/kr/app/cooki/id6747327839](https://apps.apple.com/kr/app/cooki/id6747327839)

## 📖 프로젝트 배경

- 요리 초보자의 27%가 처음부터 요리하는 것을 두려워하고, 38%가 레시피 없이 요리하는 것에 자신감이 없다는 조사 결과에서 보듯이, 접근하기 쉬운 개인화된 요리 가이드에 대한 니즈가 명확히 존재
- 특히 냉장고 속 남은 재료로 즉석 요리를 만들고 싶어하는 사용자들이 적절한 레시피를 찾는 데 어려움을 겪고 있으며, 기존 레시피 앱들은 단순 검색 기반으로만 제공되어 이러한 개별적 상황을 반영하지 못하는 한계 보유
- 이에 따라 생성형 AI를 활용하여 사용자의 보유 재료나 음식 사진을 바탕으로 실시간 맞춤형 레시피를 생성하고, 커뮤니티 기반 경험 공유가 가능한 통합 플랫폼 개발 필요성 확인
- 요리 진입 장벽을 낮추고 개인 상황에 최적화된 요리 솔루션을 제공함으로써, 누구나 쉽게 요리를 시작하고 즐길 수 있는 환경 조성을 목표로 프로젝트 기획

## 🌟 수행 내용 및 성과

### AI 레시피 생성 및 관리 시스템 구축
- **Gemini AI 기반 멀티모달 레시피 생성 시스템 구축**
  - Gemini 2.0-flash 모델 연동으로 텍스트 입력 및 이미지 인식 기반의 멀티모달 레시피 생성 기능 개발
  - Few-shot 프롬프트 기법과 사용자 선호도(맵기, 아이 친화적 등) 반영 맞춤형 프롬프트 엔지니어링 구현
  - 다국어 대응 프롬프트 구성 및 비음식 이미지 대응 fallback JSON 시스템 구현으로 안정성 확보
  - 카테고리/재료/조리시간 등 명세 기준 엄격 적용을 통한 일관된 레시피 품질 보장
  - 토큰 카운팅 및 비용 모니터링 시스템 구축으로 입력/출력 토큰 수와 실시간 API 사용 비용 추적

- **AI 입력 검증 시스템 구현 및 품질 개선**
  - Gemini 1.5-flash 모델을 활용한 별도 입력 검증 시스템 구축
  - 비레시피성 입력, 명령어 조작, 프롬프트 악용 시도 사전 필터링 로직 구현
  - 입력 유효성 검증과 레시피 생성을 분리한 2단계 검증 시스템 도입으로 부적절한 레시피 생성률을 **85%에서 12%로 감소**
  - Flutter Image Compress를 활용한 이미지 압축 최적화로 API **토큰 사용량 35% 절약** 및 생성 속도 향상
  - JSON Schema 기반 구조화된 응답 형식 정의로 파싱 오류 감소

- **레시피 저장 및 관리 시스템**
  - Firestore와 Firebase Storage 연동을 통한 레시피 및 이미지 저장 기능 구현
  - 기존 순차 처리 방식을 병렬 처리로 변경하여 AI 레시피 생성과 이미지 업로드 동시 실행으로 생성 시간 **40% 단축**
  - 생성된 레시피의 편집, 삭제, 공개/비공개 설정 및 커뮤니티 공유 기능 개발
  - 이미지 압축과 리사이징을 통한 업로드 시간 **25% 단축** 및 스토리지 비용 최적화

### 리뷰 시스템 및 번역 기능
- **리뷰 관리 및 상호작용 기능**
  - 별점, 텍스트, 이미지(최대 5장)를 포함한 종합 리뷰 시스템 개발
  - 리뷰 작성/수정/삭제 기능과 부적절한 콘텐츠 신고 시스템 구현
  - 최신순/별점순 정렬로 사용성 향상
  - Firestore 서브컬렉션 구조 활용으로 리뷰 조회 성능 개선
  - 다중 이미지 업로드 시 개별 압축 처리 및 병렬 업로드로 처리 시간 40% 단축
  - 리뷰 수정 시 기존 원격 이미지와 새로 추가된 로컬 이미지를 통합 처리하는 하이브리드 시스템으로 편집 과정에서 일관된 사용자 경험 제공

- **다국어 리뷰 번역 시스템 구축**
  - Google Cloud Translation API와 Firebase Cloud Functions 연동을 통한 실시간 번역 기능 구현
  - 리뷰 작성 시 언어 자동 감지 시스템 도입으로 다국어 사용자 간 원활한 소통 지원
  - 리뷰 언어 감지를 비동기 백그라운드로 처리하여 리뷰 작성 완료 시간을 **약 3초 단축** 및 사용자 경험 개선

### 다국어 지원 및 음성 인식
- **언어 설정 및 국제화 시스템**
  - Flutter l10n을 활용한 한국어/영어 다국어 UI 구현
  - SharedPreferences 기반 언어 설정 저장 및 언어 설정 페이지로 인한 실시간 언어 변경 기능
  - 사용자 디바이스 언어 자동 감지 및 기본 언어 설정으로 첫 사용자 경험 개선

- **음성 인식 기반 검색 시스템**
  - Flutter Speech-to-Text 플러그인 연동으로 음성 입력 기반 레시피 검색 기능 구현
  - 한국어/영어 음성 인식 지원으로 접근성 향상
  - 음성 입력 중 실시간 텍스트 변환 및 오류 처리 로직 구현

### 레시피 외부 공유 기능
  - Share Plus 패키지를 활용한 텍스트와 이미지 결합 공유 기능 구현
  - 레시피 정보의 구조화된 포맷팅으로 가독성 있는 공유 콘텐츠 생성
  - 안드로이드/iOS 기본 공유 시트를 통해 카카오톡, 이메일, 메모 앱 등 다양한 플랫폼으로 간편하게 레시피 전송 가능

### UI/UX 최적화 및 성능 개선
  - 클라이언트 사이드 폼 검증 시스템으로 레시피 제목, 재료, 조리과정 등 필수 필드 실시간 유효성 검사
  - 확대/축소 및 슬라이드 기능을 포함한 이미지 뷰어로 리뷰 이미지 조회 편의성 강화
  - CachedNetworkImage를 활용한 이미지 캐싱 시스템으로 반복 로딩 시간 단축 및 데이터 사용량 절약
  - Shimmer 로딩 애니메이션 구현으로 데이터 로딩 중 인지된 성능 향상 및 사용자 대기 경험 개선
  - PopScope를 활용한 사용자 데이터 손실 방지 및 확인 다이얼로그 시스템 구현

### 아키텍처 및 예외 처리 시스템
- **전계층 예외 처리 및 사용자 경험 보장**
  - 모든 내부 계층에서 발생하는 예외를 ViewModel의 try-catch에서 일괄 포착하여 앱 크래시 방지
  - 포착된 예외를 도메인별 Enum 에러 키로 변환 후 UI에서 다국어 메시지로 매핑하는 2단계 에러 처리로 기술적 예외와 사용자 메시지 분리
  - 국제화 의존성을 비즈니스 로직에서 완전 제거하여 ViewModel 단위 테스트 환경 구축 및 관심사 분리 달성
  - 일관된 에러 플로우를 통해 네트워크 오류, 파일 처리 실패 등 다양한 예외 상황에서 적절한 사용자 안내 제공

- **코드 품질 및 유지보수성 개선**
  - MVVM 아키텍처와 Repository/DataSource 패턴 기반의 계층 구조를 적용해 책임을 분리하고 재사용성 강화
  - Riverpod을 활용한 전역 상태 관리와 기능별 ViewModel 설계로 상태 흐름을 단순화하고 유지보수 효율 향상
  - 공통 위젯 컴포넌트화를 통한 UI 일관성 확보 및 개발 효율성 증대
  - 로그 시스템과 Firebase Crashlytics 연동으로 실시간 오류 모니터링 체계 구축
  - 타입 안전성을 위한 DTO 및 Entity 계층 분리로 런타임 오류 방지

## 🧭 기술적 의사결정

**1. Gemini AI 모델 선택 및 2단계 검증 시스템 구축**

- **요구 사항**  
  사용자가 입력한 텍스트나 이미지로부터 높은 품질의 레시피를 안정적으로 생성하면서, 비음식 관련 입력이나 악의적 프롬프트 조작을 효과적으로 차단해야 함

- **의사 결정**  
  `Gemini 1.5-flash`와 `Gemini 2.0-flash` 모델을 역할별로 분리한 2단계 검증 시스템 구축을 결정
  - **1단계 검증**: Gemini 1.5-flash로 입력 유효성 검사 전담하여 비레시피성 입력, 명령어 조작, 프롬프트 인젝션 시도를 사전 필터링
  - **2단계 생성**: Gemini 2.0-flash로 실제 레시피 생성 처리하여 최신 모델의 성능과 안정성 확보
  - **JSON Schema 강제**: 구조화된 응답 형식으로 파싱 오류 방지 및 일관된 데이터 품질 보장
  - **토큰 최적화**: 검증 단계에서 간단한 boolean 응답으로 API 비용 절약, 생성 단계에서만 복잡한 레시피 데이터 요청

```dart
// 검증 모델 설정
_validationModel = googleAI.generativeModel(
  model: 'gemini-1.5-flash',
  generationConfig: GenerationConfig(
    responseMimeType: 'application/json',
    responseSchema: Schema.object(
      properties: {'isValid': Schema.boolean()},
    ),
  ),
);

// 생성 모델 설정  
_recipeGenerationModel = googleAI.generativeModel(
  model: 'gemini-2.0-flash',
  generationConfig: GenerationConfig(
    responseMimeType: 'application/json',
    responseSchema: Schema.object(/* 레시피 구조 정의 */),
  ),
);
```
<span style="display: block; height: 1px;"></span>

**2. 멀티모달 프롬프트 엔지니어링 아키텍처**

- **요구 사항**  
  텍스트 입력, 이미지 입력, 또는 둘의 조합으로 다양한 상황에 대응하는 레시피 생성이 가능해야 하며, 한국어와 영어 사용자 모두에게 일관된 품질의 결과 제공이 필요

- **의사 결정**  
  `템플릿 기반 동적 프롬프트 시스템`과 `다국어 마크다운 파일 구조` 도입을 결정
  - **모듈화된 프롬프트**: 기본 템플릿, 텍스트 컨텍스트, 선호도 섹션을 독립적인 마크다운 파일로 분리하여 유지보수성 향상
  - **다국어 지원**: `assets/prompts/ko/`, `assets/prompts/en/` 구조로 언어별 프롬프트 관리
  - **플레이스홀더 시스템**: `__COOKI_*__` 형태의 커스텀 플레이스홀더로 런타임 동적 구성
  - **Few-shot 학습**: 프롬프트 내 예시 레시피 포함으로 일관된 출력 형식과 품질 확보

```dart
Future<String> _buildRecipePrompt({
  String? textInput,
  Set<String>? preferences,
  required bool hasImage,
  required String textOnlyRecipePromptPath,
  required String imageRecipePromptPath,
}) async {
  if (hasImage) {
    String imagePrompt = await rootBundle.loadString(
      'assets/prompts/$imageRecipePromptPath',
    );
    
    // 동적 섹션 구성
    String textContextSection = textInput?.isNotEmpty == true 
        ? await _buildTextContextSection(textInput!)
        : '';
    String preferencesSection = await _buildPreferencesSection(preferences);
    
    return imagePrompt
        .replaceAll(AppConstants.textContextSectionPlaceholder, textContextSection)
        .replaceAll(AppConstants.preferencesSectionPlaceholder, preferencesSection);
  }
  // 텍스트 전용 프롬프트 처리...
}
```
<span style="display: block; height: 1px;"></span>

**3. Firebase Cloud Functions 기반 번역 시스템**

- **요구 사항**  
  실시간 번역 기능이 필요하며, 클라이언트에서 직접 Google Translation API를 호출하기에는 보안상 API 키 노출 위험이 존재

- **의사 결정**  
  `Firebase Cloud Functions`를 중간 계층으로 활용한 서버리스 번역 시스템 구축을 결정
  - **보안성**: Google Cloud Translation API 인증 정보를 서버 측에서 안전하게 관리
  - **확장성**: 서버리스 아키텍처로 사용량에 따른 자동 스케일링 및 비용 최적화
  - **언어 감지**: 번역과 언어 감지를 별도 함수로 분리하여 필요에 따른 선택적 호출 가능
  - **에러 처리**: Cloud Functions 레벨에서 통합된 오류 처리 및 클라이언트에 구조화된 응답 반환

```javascript
exports.translateText = onCall({ region: "asia-northeast3" }, async (request) => {
  try {
    const { text, targetLanguage, sourceLanguage } = request.data;
    
    const translationRequest = {
      parent: `projects/${projectId}/locations/global`,
      contents: [text],
      mimeType: 'text/plain',
      targetLanguageCode: targetLanguage,
      ...(sourceLanguage && { sourceLanguageCode: sourceLanguage }),
    };
    
    const [response] = await translationClient.translateText(translationRequest);
    
    return {
      success: true,
      translatedText: response.translations[0].translatedText,
      detectedSourceLanguage: response.translations[0].detectedLanguageCode || sourceLanguage
    };
  } catch (error) {
    throw new Error('Translation failed: ' + error.message);
  }
});
```

**2. 비동기 언어 감지 및 번역 시스템**

- **요구 사항**  
  다국어 사용자 환경에서 리뷰 작성 및 열람 시 언어 장벽을 해소해야 함

- **의사 결정**  
  리뷰 저장과 언어 감지를 분리하여 UX 향상 및 성능 최적화
    - 리뷰 저장 즉시 UI 응답성 보장을 위해 언어 감지를 백그라운드로 이동
    - Cloud Functions를 활용한 Google Cloud Translation API 연동
    - 언어 감지 결과는 비동기적으로 Firestore에 업데이트하여 사용자 대기 시간 제거

```dart
Future<String> saveReview(Review review) async {
  final reviewId = await _reviewDataSource.saveReview(review);
  
  // 비동기적으로 언어 감지 및 업데이트 실행 (await 없음)
  _detectLanguageAndUpdate(reviewId, review.text);
  
  return reviewId;
}

void _detectLanguageAndUpdate(String reviewId, String? text) async {
  if (text == null || text.isEmpty) return;
  
  try {
    final language = await _translationRepository.detectLanguage(text);
    await _reviewDataSource.updateReviewLanguage(reviewId, language);
  } catch (e) {
    _logger.logError('Language detection failed', e);
  }
}
```

**3. 병렬 이미지 처리 및 업로드 최적화**

- **요구 사항**  
  레시피 생성 및 리뷰 작성 시 다수 이미지의 빠른 처리와 업로드 필요

- **의사 결정**  
  이미지 압축과 업로드를 병렬화하여 처리 속도 개선
    - `Future.wait`를 활용한 다중 이미지 병렬 압축 및 업로드
    - 이미지 생성과 레시피 저장을 동시에 진행하는 비동기 워크플로우 구현
    - 이미지 품질과 파일 크기의 최적 균형점 도출을 위한 압축 알고리즘 조정

```dart
Future<List<String>> uploadImages(List<File> images, String uid) async {
  final compressedImages = await Future.wait(
    images.map((image) => compressImage(image))
  );
  
  final uploadTasks = compressedImages.map((image) => 
    _storageDataSource.uploadImage(image, uid)
  );
  
  return await Future.wait(uploadTasks);
}
```

## 🌱 문제 해결

**1. AI 레시피 생성의 정확도와 관련성 향상**

- **문제 상황**  
  초기 모델에서는 사용자 입력(특히 이미지)에 대한 오인식이 빈번했고, 음식과 무관한 이미지에 대해서도 레시피를 생성하는 문제 발생

- **해결 과정**
    - 기존 단일 프롬프트 방식에서 입력 검증과 레시피 생성을 분리하는 2단계 아키텍처로 전환
    - Gemini v1.5-flash 모델을 활용한 사전 검증 로직 구현으로 유효하지 않은 입력 필터링
    - 이미지 유효성 검사를 위한 별도 프롬프트 설계 및 구현
    - 다양한 예외 케이스(비음식 이미지, 모호한 설명 등)에 대한 fallback 메커니즘 구축

- **최종 결과**  
  레시피 생성 오류율이 **65% 감소**하고 사용자 만족도가 **40% 향상**되었으며, 비정상적 입력에 대한 명확한 안내 제공으로 UX 개선

**2. 다국어 환경에서의 일관된 사용자 경험 보장**

- **문제 상황**  
  앱의 글로벌화를 위한 다국어 지원 시 UI 레이아웃 깨짐, 번역 불일치, 언어별 데이터 처리 차이 등의 문제 발생

- **해결 과정**
    - Flutter Intl 패키지를 활용한 체계적인 다국어 지원 아키텍처 구축
    - 모든 하드코딩된 문자열을 ARB 파일 기반 지역화 문자열로 전환
    - 언어별 프롬프트 파일을 외부 마크다운으로 분리하여 유지보수성 향상
    - 레시피 카테고리 등 다국어 매핑이 필요한 데이터에 대한 언어 간 변환 로직 구현

- **최종 결과**  
  영어와 한국어 사용자 모두에게 일관된 UX를 제공하고, 앱의 글로벌 접근성이 향상되었으며, 향후 추가 언어 지원을 위한 확장 가능한 아키텍처 구축

**3. 레시피 생성 및 저장 성능 최적화**

- **문제 상황**  
  이미지와 함께 레시피 생성 시 처리 시간이 길어져 사용자 이탈률 증가 및 불만 제기

- **해결 과정**
    - 레시피 생성과 이미지 업로드를 직렬에서 병렬 처리로 전환
    - 이미지 압축 알고리즘을 적용해 업로드 속도 개선 및 스토리지 비용 절감
    - 이미지 캐싱 및 지연 로딩 전략을 통한 UI 응답성 개선
    - 비동기 작업의 효율적 관리를 위한 Riverpod 상태 관리 최적화

- **최종 결과**  
  레시피 생성 및 저장 소요 시간이 **45% 단축**되고, 사용자 만족도가 개선되었으며, Firebase 스토리지 비용이 **25% 절감**되는 효과 달성

## 🎞️ 시연 영상
<div align="center"> 
<a href="https://www.youtube.com/watch?v=0cTYv7v8H4A">
  <img src="../../images/cooki/video_preview.png" alt="Watch the Video" width="230" />
</a>
</div>
<br>